---
source_url: https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html
date_created: 2025-01-21T04:55:53.217Z
---

# Notes: ownership-essentials

Here are concise study notes on ownership in Rust, covering key concepts, explanations, and examples:

## Ownership Rules

1. **Each value in Rust has a variable that is its owner.**
2. **There can only be one owner at a time.**
3. **When the owner goes out of scope, the value will be dropped.**

### The Stack and the Heap
- The **stack** stores values in the order it gets them and removes them in the opposite order (LIFO).
- The **heap** is less organized - you request a chunk of memory from the memory allocator at runtime.
- Values on the stack have a **known, fixed size**. Values with an **unknown size** at compile time must go on the heap.
- Pushing to the stack is faster than allocating on the heap.

### String Type and Memory Allocation
- **String** is a data type that stores data on the **heap**.
- Creating a String from a string literal uses **String::from()**.
- When a String goes out of scope, Rust calls **drop()** to free the memory.

### Move Semantics
- When a value is **assigned** to another variable, the **value is moved** and the original variable is **invalidated**.
- This prevents **double free** errors when both variables go out of scope.
- Calling **clone()** creates a **deep copy** of heap data.
- Types like integers implement the **Copy** trait and are **trivially copied** on the stack.

### Ownership and Functions
- Passing a variable to a function will **move** or **copy** it.
- Returning values can also **transfer ownership**.
- Using **tuples** allows returning multiple values.

### References
- Rust has **references** to allow using a value without transferring ownership.

### Code Examples

```rust
let s1 = String::from("hello"); // s1 is valid
let s2 = s1; // s1 is invalidated, s2 now owns the String

let x = 5; // integers implement Copy
let y = x; // x is still valid after copying

fn takes_ownership(s: String) { // s comes into scope
    println!("{s}"); // s is dropped here
}

fn makes_copy(i: i32) { // i is a copy of the value
    println!("{i}"); // i goes out of scope, nothing happens
}
```

**Bold** terms highlight key Rust ownership concepts and rules.

---
Generated by Web Notes AI
