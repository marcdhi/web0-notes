---
source_url: https://doc.rust-lang.org/book/ch03-02-data-types.html
date_created: 2025-01-21T04:52:48.186Z
---

# Notes: data-types-in-rust

Here are concise yet comprehensive study notes on data types in Rust, covering key concepts, examples, and important details:

## Data Types in Rust

### Scalar Types

- **Integers**
    - Signed (i8, i16, i32, i64, i128, isize) and unsigned (u8, u16, u32, u64, u128, usize)
    - isize and usize depend on system architecture
    - Integer literals: decimal, hex, octal, binary, byte
    - Integer overflow: panics in debug mode, wraps in release mode
- **Floating-point** (f32, f64)
    - f64 is default, follows IEEE-754 standard
- **Booleans** (bool)
    - Values: true and false
- **Characters** (char)
    - Unicode scalar values, 4 bytes in size
    - Ex: 'z', 'â„¤', 'ðŸ˜»'

### Compound Types

- **Tuples**
    - Fixed-length, heterogeneous collection
    - Ex: `let tup: (i32, f64, u8) = (500, 6.4, 1);`
    - Access elements with destructuring or indexing
- **Arrays**
    - Fixed-length, homogeneous collection
    - Ex: `let a = [1, 2, 3, 4, 5];`
    - Access elements with indexing
    - Invalid index access causes panic

### Key Operations

- Basic arithmetic operations (+, -, *, /, %)
- Indexing: array[index], tuple.index
- Type annotations: `let x: i32 = 5;`

### Important Points

- **Statically typed**: Types known at compile-time
- **Memory safety**: Invalid memory access prevented
- **Stack vs Heap**: Scalar and some compound types on stack, vector on heap

### Examples

```rust
let x = 10; // i32 by default
let y: u64 = 0xff; // type annotation

let t = true;
let f: bool = false;  // with explicit type annotation

let c = 'z';
let z: char = 'â„¤';  // with explicit type annotation

let tup: (i32, f64, u8) = (500, 6.4, 1);
let (x, y, z) = tup; // destructuring

let arr = [1, 2, 3, 4, 5];
let first = arr[0];
```

---
Generated by Web Notes AI
