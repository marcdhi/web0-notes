---
source_url: https://doc.rust-lang.org/book/ch03-02-data-types.html
date_created: 2025-01-21T04:38:52.766Z
---

# Notes: [object Promise]

Here are comprehensive yet concise study notes for the "Data Types" section from the Rust Programming Language book:

## Data Types

**Scalar Types**

### Integer Types

- **Signed integers**: `i8`, `i16`, `i32`, `i64`, `i128`, `isize` (pointer size)
- **Unsigned integers**: `u8`, `u16`, `u32`, `u64`, `u128`, `usize` (pointer size)
- Can use decimal, hex, octal, binary, byte literals
- **Integer Overflow**:
    - Debug mode: integers panic on overflow
    - Release mode: integers wrap around on overflow
    - Can use methods like `wrapping_add` to handle overflow explicitly

### Floating-Point Types

- `f32` (single precision), `f64` (double precision)
- Follow IEEE-754 standard

### Boolean Type

- `bool` with values `true` and `false`

### Character Type

- `char` represents a Unicode Scalar Value of 4 bytes
- Uses single quotes: `let c = 'z'`

**Compound Types**

### Tuple Type

- **Tuples** group values of different types in one compound type
- Fixed length, cannot grow or shrink
- Access elements with destructuring or indexing
- `()` is a special **unit** value/type

### Array Type

- **Arrays** are collections of values of the **same type**
- Fixed length, cannot grow or shrink
- Access elements with indexing
- Use when size is known at compile time
- Can initialize with `[value; length]`
- Out-of-bounds indexing causes runtime panic

**Key Terms**

- **Scalar**: Represents a single value
- **Compound**: Groups multiple values
- **Statically Typed**: Types must be known at compile time

**Examples**

```rust
let x: i32 = 5; // Annotation
let y = 10; // Compiler infers type
let z: u64 = 0xFFFF_FFFF_FFFF_FFFF; // Hex literal

let tup: (f32, bool, char) = (3.14, true, 'x');
let (a, b, c) = tup; // Destructuring

let arr = [1, 2, 3, 4, 5]; // Array
let arr2: [u8; 3] = [0; 3]; // Initialized array
```

These study notes cover the key data types in Rust, including scalar types like integers, floats, booleans, and characters, as well as compound types like tuples and arrays. It highlights important concepts like type annotations, integer overflow handling, tuple destructuring, array initialization, and out-of-bounds indexing. The notes are structured using headings, bullet points, code examples, and brief explanations for better understanding and revision.

---
Generated by Web Notes AI
